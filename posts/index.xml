<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on void?</title>
    <link>https://netotz.github.io/posts/</link>
    <description>Recent content in Posts on void?</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 29 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://netotz.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>El Tao y el lenguaje como ilusión de la dualidad</title>
      <link>https://netotz.github.io/posts/dualidad/</link>
      <pubDate>Wed, 29 May 2024 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/dualidad/</guid>
      <description>La dualidad es un concepto que engloba dos principios antagónicos pero coexistentes y eternamente enlazados, tales como el bien y el mal, el día y la noche, el blanco y el negro, como es arriba es abajo, vida y muerte, iniciados y profanos, el mundo de afuera y el yo de adentro; por mencionar solo algunas de muchas dualidades.
Estos pares de conceptos opuestos pero complementarios son más que solo antónimos, pues el concepto de dualidad va más allá de la semántica al simbolizar polos de una misma realidad o fenómeno.</description>
    </item>
    
    <item>
      <title>A simple application of refactorization</title>
      <link>https://netotz.github.io/posts/refactor-cp/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/refactor-cp/</guid>
      <description>Valuable code is such because it works. It truly doesn&amp;rsquo;t matter how such code looks or under what standards or rules it was written. If it doesn&amp;rsquo;t work, it&amp;rsquo;s trash. If it works, it adds value.
This is something that almost all programmers know. We should get this taught early in our journeys because we ought to solve problems by writing code. The satisfaction that a developer gets when she sees her program working as expected and how it actually solves a real problem is unexplainable (she can finally go to sleep).</description>
    </item>
    
    <item>
      <title>The process of designing a new algorithm</title>
      <link>https://netotz.github.io/posts/a-fvs/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/a-fvs/</guid>
      <description>Introduction Earlier in the year I wrote about how the objective function of an optimization problem is decomposed and partially evaluated so an algorithm that uses that function runs faster. I found this technique so interesting that I tried to explain it in that post. But the goal wasn&amp;rsquo;t to just understand the decomposing of an objective function. I needed to design a fast algorithm to solve the $\alpha$-neighbor $p$-center problem (ANPCP), as I mentioned in the other post, and while researching to do so, I came across the concept of the fast interchange or fast swap and how it was applied to other location problems (not the ANPCP).</description>
    </item>
    
    <item>
      <title>The SOLID Principles</title>
      <link>https://netotz.github.io/posts/solid/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/solid/</guid>
      <description>Awesome articles about the topic:
 SOLID Principles Around You    In software engineering, SOLID is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible, and maintainable.
 But when to apply SOLID? Ardalis recommends following the Pain Driven Development or PDD:
 Write code using the simplest techniques you know to get the problem solved. Trying to always apply all SOLID principles would result in a premature optimization of the application&amp;rsquo;s design.</description>
    </item>
    
    <item>
      <title>The Four Pillars of Object Oriented Programming</title>
      <link>https://netotz.github.io/posts/four-pillars-oop/</link>
      <pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/four-pillars-oop/</guid>
      <description>The four pillars of OOP are:
 Abstraction Encapsulation Inheritance Polymorphism  But before describing each, basic concepts of OOP are needed to understand.
Basic OOP Object Oriented Programming (OOP) is a programming paradigm that structures a software program into reusable pieces of code blueprints, which are called classes.
Class A class is a code template or blueprint that describes what an object is and what it does, by defining attributes to store data and implementing methods or behaviors to use that data.</description>
    </item>
    
    <item>
      <title>C# Wizardry - Understanding delegates with custom LINQ methods</title>
      <link>https://netotz.github.io/posts/csharp-wizardry/delegates/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/csharp-wizardry/delegates/</guid>
      <description>The content below is retrieved from Jupyter notebooks that you can find in this repository.
Source: Microsoft documentation.
 A delegate encapsulates a method.
Actions System.Action is the standard library type for void delegates, methods that don&amp;rsquo;t return a value. By default it&amp;rsquo;s parameterless, but it can have parameters with generics.
Action action = () =&amp;gt; Console.WriteLine(&amp;#34;Action done.&amp;#34;); // invoked as method call action() Action done. // user-declared delegate, no parameters delegate void MyAction(); MyAction myAction = () =&amp;gt; Console.</description>
    </item>
    
    <item>
      <title>C# Wizardry - Understanding events</title>
      <link>https://netotz.github.io/posts/csharp-wizardry/events/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/csharp-wizardry/events/</guid>
      <description>The content below is retrieved from Jupyter notebooks that you can find in this repository.
Source: Microsoft documentation.
 Events enable a class or object (the publisher) to notify other classes or objects (the subscribers) when something occurs.
 The publisher determines when to raise an event. It can have multiple subscribers. The subscriber determines how to handle an event when it&amp;rsquo;s raised. It can be subscribed to multiple events.  System.</description>
    </item>
    
    <item>
      <title>Decomposing an objective function</title>
      <link>https://netotz.github.io/posts/decomposing-of/</link>
      <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/decomposing-of/</guid>
      <description>As the thesis for the BSc Software Engineering, I&amp;rsquo;m researching heuristic algorithms in the Operations Research field. Specifically, my mentor and I are implementing heuristics for the $\alpha$-neighbor $p$-center problem (ANPCP for short). Because the literature about it is scarce, we&amp;rsquo;ve been reading papers that use heuristic algorithms for similar problems, and trying to adapt them to the ANPCP. In this process, I found it interesting how some authors decompose the objective function of a problem and evaluate it step by step while, at the same time, applying a heuristic to the current solution.</description>
    </item>
    
    <item>
      <title>Aristotle, Boole and Shannon</title>
      <link>https://netotz.github.io/posts/aristotle-boole-shannon/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/aristotle-boole-shannon/</guid>
      <description>The other day I started to watch Computer Science Crash Course on YouTube. The first two videos explain the early History of computers, starting from the abacus: humans needed to store quantities; up to the 1950s. They explain how technology stopped being mechanical thanks to relays and how it was improved with vaccum tubes and then with transistors. Each one of these innovations allowed for faster propagation of electrical signals.</description>
    </item>
    
    <item>
      <title>Pilot</title>
      <link>https://netotz.github.io/posts/pilot/</link>
      <pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://netotz.github.io/posts/pilot/</guid>
      <description>It&amp;rsquo;s been a few months since I wanted to start a programming blog, mainly because I want to write about how I struggle with dumb stuff and how I solve it, if so. To be honest now I feel lazy about writing but I feel like I&amp;rsquo;m in debt. I&amp;rsquo;ve been saved lots of times by strange programmers in the Internet who decided to magnificently contribute to the whole humanity, by posting their solutions.</description>
    </item>
    
  </channel>
</rss>
